<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CodingPrime</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Inconsolata%7COswald%7COxygen%7CSource+Code+Pro">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/highlight.js.solarized.css">
  </head>
  <body>
    <header>
      <section class="container">
        <h1><a href="/">CodingPrime</a></h1><span>&lt;strong&gt;kung fu&lt;/strong&gt;</span><a href="https://github.com/t3hpr1m3/codingprime.com"><img style="position: absolute; top: 0; right: 0; border: 0" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
      </section>
    </header>
    <main class="container">
      <article class="post">
        <header>
          <time datetime="2010-08-13 23:08">August 13, 2010</time>
          <h2>Findable plugin
          </h2>
        </header>
        <section><p>Probably the strangest first blog post ever, but here goes.  I'm migrating a
product from Classic ASP to Rails.  The bulk of its data is accessed via a
TCP service, which accepts/responds with XML.  Unfortunately, it's a custom
protocol, so I'm forced to do all the packet building/transport myself.  No big
deal.</p>
<p>The top level resource is a list of accounts.  These accounts don't change over
the course of a session, so I'm caching them to avoid the round trip.  This
list of accounts is referenced in some way on every page, so fast access to a
particular account is important.  I started out by writing a custom <code>find</code>
method, which took a hash of arguments.  This works, but looks weird next to
all the other ActiveRecord goodness in the app.  Enter:
<a href="http://www.github.com/t3hpr1m3/findable">Findable</a>.</p>
<!--more-->
<p>My Account model looks similar to this:</p>
<pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">'builder'</span>
<span class="hljs-keyword">require</span> <span class="hljs-string">'nokogiri'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:account_id</span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:account_type</span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:description</span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:balance</span>

  <span class="hljs-keyword">self</span>.build_request
    xml_text = <span class="hljs-string">""</span>
    Builder::XmlMarkup.new( <span class="hljs-symbol">:target</span> =&gt; xml_text ) { <span class="hljs-params">|x|</span>
      x.instruct!
      x.getaccounts { <span class="hljs-params">|g|</span> g.context( Config.context ) }
    }
    xml_text
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">self</span>.from_xml(n)
    a = Account.new
    a.account_id = n.at_xpath(<span class="hljs-string">"id"</span>).text.to_i
    a.account_type = n.at_xpath(<span class="hljs-string">"type"</span>).text
    a.description = n.at_xpath(<span class="hljs-string">"description"</span>).text
    a.balance = n.at_xpath(<span class="hljs-string">"balance"</span>).text.to_f
    a
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">self</span>.accounts
    Rails.cache.fetch( <span class="hljs-string">"accounts"</span> ) {
      req = <span class="hljs-keyword">self</span>.build_request
      resp = send_and_receive(req) <span class="hljs-comment"># custom library function</span>
      Nokogiri::XML(resp).xpath(<span class="hljs-string">"accounts/account"</span>).collect <span class="hljs-keyword">do</span> <span class="hljs-params">|account|</span>
        from_xml(account)
      <span class="hljs-keyword">end</span>
    }
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">self</span>.find( options = {} )
    <span class="hljs-keyword">if</span> accounts.<span class="hljs-literal">nil</span>?
      <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">if</span> options.keys.length == <span class="hljs-number">0</span>
        accounts
      <span class="hljs-keyword">else</span>
        accounts.select { <span class="hljs-params">|a|</span>
          is_match = <span class="hljs-literal">true</span>
          options.each { <span class="hljs-params">|key, value|</span>
            <span class="hljs-keyword">if</span> a.instance_variable_get( <span class="hljs-string">"@<span class="hljs-subst">#{key}</span>"</span> ) != value
              is_match = <span class="hljs-literal">false</span>
              <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">end</span>
          }
          is_match
        }
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>
<p>I've stripped this down to bare bones for clarity, leaving out all the sanity
checking.  You can probably guess what a call to <code>find</code> looks like:</p>
<pre><code class="hljs ruby">@account = Account.find( { <span class="hljs-symbol">:account_id</span> =&gt; <span class="hljs-number">34529</span> } )</code></pre>
<p>This works just fine, but it obviously needs some work.  First of all, there's
no way for me to request just 1 account.  <code>@account</code> here would always be an
array, and I'd always be referencing <code>@account[0]</code>.  I've also got several
other models that work similarly, so I need a way to generically apply this
<code>finder</code> logic to several models.  There's probably a way to do this that I'm
not aware of, and if anyone ever actually reads this post, I'll probably be
ridiculed horribly, but since I couldn't find anything, I decided to write
<a href="http://www.github.com/t3hpr1m3/findable">Findable</a>.</p>
<p>Basically, it throws a bunch of ActiveRecord-ish finders onto your model, so
you can treat it as if it were an ActiveRecord for the purposes of filtering.
Implementing Finder is pretty easy:</p>
<ul>
<li>include <code>Findable</code></li>
<li>Replace <code>attr_accessor</code> with <code>findable_attribute</code></li>
<li>Call <code>findable_method</code>, passing it your method for retrieving data</li>
</ul>
<p>World domination. Taking the account model:</p>
<pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span>  <span class="hljs-title">include</span> <span class="hljs-title">Findable</span></span>
  findable_attribute <span class="hljs-symbol">:account_id</span>
  findable_attribute <span class="hljs-symbol">:account_type</span>
  findable_attribute <span class="hljs-symbol">:description</span>
  findable_attribute <span class="hljs-symbol">:balance</span>
  findable_method <span class="hljs-symbol">:accounts</span>

  <span class="hljs-keyword">self</span>.build_request
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">self</span>.from_xml(n)
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">self</span>.accounts
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>
<p>The find method disappears entirely, replaced by brand new magic finders:</p>
<pre><code class="hljs ruby">Account.find(<span class="hljs-symbol">:first</span>, <span class="hljs-symbol">:account_type</span> =&gt; <span class="hljs-string">'checking'</span>)
Account.find_by_account_type(<span class="hljs-string">'checking'</span>)
Account.find(<span class="hljs-symbol">:last</span>)
Account.all</code></pre>
<p>And so on.  If you have an attribute that you'd like to use as a resource ID
for a restful route, just pass <code>true</code> as the second argument to
<code>findable_attribute</code>:</p>
<pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>
  <span class="hljs-comment"># ...</span>
  findable_attribute <span class="hljs-symbol">:account_id</span>, <span class="hljs-literal">true</span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span></code></pre>
<p>and now in your controller:</p>
<pre><code class="hljs ruby">@account = Account.find(params[<span class="hljs-symbol">:id</span>])</code></pre>
<p>works!  If your <code>findable_method</code> would somehow benefit from having the
<code>options</code> hash passed in (possibly using it to filter the results before
they're actually received), just pass <code>true</code> in your call to <code>findable_method</code>.</p>
<pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span></span>
  findable_method <span class="hljs-symbol">:accounts</span>, <span class="hljs-literal">true</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_request</span><span class="hljs-params">(options)</span></span>
    xml_text = <span class="hljs-string">""</span>
    Builder::XmlMarkup.new( <span class="hljs-symbol">:target</span> =&gt; xml_text ) { <span class="hljs-params">|x|</span>
      x.instruct!
      x.getaccounts { <span class="hljs-params">|g|</span>
        g.context(Config.context)
        g.account_type(options[<span class="hljs-symbol">:account_type</span>]) <span class="hljs-keyword">if</span> options.keys.<span class="hljs-keyword">include</span>?(<span class="hljs-symbol">:account_type</span>)
      }
    }
    xml_text
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">accounts</span><span class="hljs-params">(options)</span></span>
    req = <span class="hljs-keyword">self</span>.build_request(options)
    resp = send_and_receive(req) <span class="hljs-comment"># custom library function</span>
    Nokogiri::XML(resp).xpath(<span class="hljs-string">"accounts/account"</span>).collect <span class="hljs-keyword">do</span> <span class="hljs-params">|account|</span>
      from_xml(account)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>
<p>This is my first plugin, and it's probably redundant, but if anyone finds it
useful, or wants to point me in the direction of the pre-existing solution to
the problem, let me know.</p>

        </section>
      </article>
      <div id="disqus_thread">
        <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'codingprime'; // required: replace example with your forum shortname
          
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the<a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </main>
    <footer class="site-footer">
      <section class="container clearfix">
        <p class="text"><span>&copy;2016 Josh Williams</span><a href="https://github.com/t3hpr1m3"><i class="fa fa-github fa-3x"></i></a><a href="https://twitter.com/t3hpr1m3"><i class="fa fa-twitter fa-3x"></i></a></p>
      </section>
    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-18124207-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>